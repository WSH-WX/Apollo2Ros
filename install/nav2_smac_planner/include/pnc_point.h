#pragma once
#include <string>
#include <vector>

// Equivalent C++ code generated by protoc for the Apollo proto file.

namespace nav2_smac_planner {
namespace common {

class SLPoint {
public:
  SLPoint(); 
  // Getters and Setters for optional fields
  bool has_s() const;
  double s() const;
  void set_s(double value);

  bool has_l() const;
  double l() const;
  void set_l(double value);

private:
  double s_;  // optional double s = 1;
  double l_;  // optional double l = 2;
  bool has_s_;
  bool has_l_;
};

class FrenetFramePoint {
public:
  FrenetFramePoint();
  bool has_s() const;
  double s() const;
  void set_s(double value);

  bool has_l() const;
  double l() const;
  void set_l(double value);

  bool has_dl() const;
  double dl() const;
  void set_dl(double value);

  bool has_ddl() const;
  double ddl() const;
  void set_ddl(double value);

private:
  double s_;
  double l_;
  double dl_;
  double ddl_;
  bool has_s_;
  bool has_l_;
  bool has_dl_;
  bool has_ddl_;
};

class SpeedPoint {
public:
  SpeedPoint();
  bool has_s() const;
  double s() const;
  void set_s(double value);

  bool has_t() const;
  double t() const;
  void set_t(double value);

  bool has_v() const;
  double v() const;
  void set_v(double value);

  bool has_a() const;
  double a() const;
  void set_a(double value);

  bool has_da() const;
  double da() const;
  void set_da(double value);

private:
  double s_;
  double t_;
  double v_;
  double a_;
  double da_;
  bool has_s_;
  bool has_t_;
  bool has_v_;
  bool has_a_;
  bool has_da_;
};

class PathPoint {
public:
  PathPoint();
  bool has_x() const;
  double x() const;
  void set_x(double value);

  bool has_y() const;
  double y() const;
  void set_y(double value);

  bool has_z() const;
  double z() const;
  void set_z(double value);

  bool has_theta() const;
  double theta() const;
  void set_theta(double value);

  bool has_kappa() const;
  double kappa() const;
  void set_kappa(double value);

  bool has_s() const;
  double s() const;
  void set_s(double value);

  bool has_dkappa() const;
  double dkappa() const;
  void set_dkappa(double value);

  bool has_ddkappa() const;
  double ddkappa() const;
  void set_ddkappa(double value);

  bool has_lane_id() const;
  const std::string& lane_id() const;
  void set_lane_id(const std::string& value);

  bool has_x_derivative() const;
  double x_derivative() const;
  void set_x_derivative(double value);

  bool has_y_derivative() const;
  double y_derivative() const;
  void set_y_derivative(double value);

private:
  double x_;
  double y_;
  double z_;
  double theta_;
  double kappa_;
  double s_;
  double dkappa_;
  double ddkappa_;
  std::string lane_id_;
  double x_derivative_;
  double y_derivative_;
  bool has_x_;
  bool has_y_;
  bool has_z_;
  bool has_theta_;
  bool has_kappa_;
  bool has_s_;
  bool has_dkappa_;
  bool has_ddkappa_;
  bool has_lane_id_;
  bool has_x_derivative_;
  bool has_y_derivative_;
};

class Path {
public:
  Path();
  bool has_name() const;
  const std::string& name() const;
  void set_name(const std::string& value);

  int path_point_size() const;
  const PathPoint& path_point(int index) const;
  PathPoint* mutable_path_point(int index);
  void add_path_point(const PathPoint& value);

private:
  std::string name_;
  std::vector<PathPoint> path_point_;
  bool has_name_;
};

class GaussianInfo {
public:
  GaussianInfo();
  bool has_sigma_x() const;
  double sigma_x() const;
  void set_sigma_x(double value);

  bool has_sigma_y() const;
  double sigma_y() const;
  void set_sigma_y(double value);

  bool has_correlation() const;
  double correlation() const;
  void set_correlation(double value);

  bool has_area_probability() const;
  double area_probability() const;
  void set_area_probability(double value);

  bool has_ellipse_a() const;
  double ellipse_a() const;
  void set_ellipse_a(double value);

  bool has_ellipse_b() const;
  double ellipse_b() const;
  void set_ellipse_b(double value);

  bool has_theta_a() const;
  double theta_a() const;
  void set_theta_a(double value);

private:
  double sigma_x_;
  double sigma_y_;
  double correlation_;
  double area_probability_;
  double ellipse_a_;
  double ellipse_b_;
  double theta_a_;
  bool has_sigma_x_;
  bool has_sigma_y_;
  bool has_correlation_;
  bool has_area_probability_;
  bool has_ellipse_a_;
  bool has_ellipse_b_;
  bool has_theta_a_;
};

class TrajectoryPoint {
public:
  TrajectoryPoint();
  bool has_path_point() const;
  const PathPoint& path_point() const;
  void set_path_point(const PathPoint& value);

  bool has_v() const;
  double v() const;
  void set_v(double value);

  bool has_a() const;
  double a() const;
  void set_a(double value);

  bool has_relative_time() const;
  double relative_time() const;
  void set_relative_time(double value);

  bool has_da() const;
  double da() const;
  void set_da(double value);

  bool has_steer() const;
  double steer() const;
  void set_steer(double value);

  bool has_gaussian_info() const;
  const GaussianInfo& gaussian_info() const;
  void set_gaussian_info(const GaussianInfo& value);

private:
  PathPoint path_point_;
  double v_;
  double a_;
  double relative_time_;
  double da_;
  double steer_;
  GaussianInfo gaussian_info_;
  bool has_path_point_;
  bool has_v_;
  bool has_a_;
  bool has_relative_time_;
  bool has_da_;
  bool has_steer_;
  bool has_gaussian_info_;
};

class Trajectory {
public:
  Trajectory();
  bool has_name() const;
  const std::string& name() const;
  void set_name(const std::string& value);

  int trajectory_point_size() const;
  const TrajectoryPoint& trajectory_point(int index) const;
  TrajectoryPoint* mutable_trajectory_point(int index);
  void add_trajectory_point(const TrajectoryPoint& value);

private:
  std::string name_;
  std::vector<TrajectoryPoint> trajectory_point_;
  bool has_name_;
};

class VehicleMotionPoint {
public:
  VehicleMotionPoint();
  bool has_trajectory_point() const;
  const TrajectoryPoint& trajectory_point() const;
  void set_trajectory_point(const TrajectoryPoint& value);

  bool has_steer() const;
  double steer() const;
  void set_steer(double value);

private:
  TrajectoryPoint trajectory_point_;
  double steer_;
  bool has_trajectory_point_;
  bool has_steer_;
};

class VehicleMotion {
public:
  VehicleMotion();
  bool has_name() const;
  const std::string& name() const;
  void set_name(const std::string& value);

  int vehicle_motion_point_size() const;
  const VehicleMotionPoint& vehicle_motion_point(int index) const;
  VehicleMotionPoint* mutable_vehicle_motion_point(int index);
  void add_vehicle_motion_point(const VehicleMotionPoint& value);

private:
  std::string name_;
  std::vector<VehicleMotionPoint> vehicle_motion_point_;
  bool has_name_;
};


}  // namespace common
}  // namespace apollo
